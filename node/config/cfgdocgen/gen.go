package main

import (
	"fmt"
	"os"
	"sort"
	"strings"

	"golang.org/x/tools/go/packages"
)

const lotusCfgPkg = "github.com/filecoin-project/lotus/node/config"
const lotusTypesPath = "node/config/types.go"
const boostTypesSrc = "./node/config/types.go"
const lotusCfgPkgAlias = "lotus_config"

// Generate the struct with all the documentation comments that is used when
// writing out the config file
func run() error {
	// Get the path to the lotus types file
	cfg := &packages.Config{Mode: packages.NeedFiles | packages.NeedSyntax}
	pkgs, err := packages.Load(cfg, lotusCfgPkg)
	if err != nil {
		return fmt.Errorf("error loading packages: %w", err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	lotusTypesSrc := ""
	for _, pkg := range pkgs {
		for _, goFile := range pkg.GoFiles {
			if strings.Contains(goFile, lotusTypesPath) {
				lotusTypesSrc = goFile
			}
		}
	}
	if lotusTypesSrc == "" {
		return fmt.Errorf("could not find %s in package %s", lotusTypesSrc, lotusCfgPkg)
	}

	// Parse the lotus types file
	lotusTypes, err := parseTypesFile(lotusTypesSrc)
	if err != nil {
		return fmt.Errorf("parsing %s: %w", lotusTypesSrc, err)
	}

	// Parse the boost types file
	boostTypes, err := parseTypesFile(boostTypesSrc)
	if err != nil {
		return fmt.Errorf("parsing %s: %w", boostTypesSrc, err)
	}

	// Prefix all the lotus types
	for k, v := range lotusTypes {
		boostTypes[lotusCfgPkgAlias+"."+k] = v
	}

	// Write out the types as a map of <type name> => <doc field>
	var outt []string
	for t := range boostTypes {
		outt = append(outt, t)
	}
	sort.Strings(outt)

	fmt.Print(`// Code generated by github.com/filecoin-project/lotus/node/config/cfgdocgen. DO NOT EDIT.

package config

type DocField struct {
	Name    string
	Type    string
	Comment string
}

var Doc = map[string][]DocField{
`)

	for _, typeName := range outt {
		typ := boostTypes[typeName]

		fmt.Printf("\t\"%s\": []DocField{\n", typeName)

		for _, f := range typ {
			fmt.Println("\t\t{")
			fmt.Printf("\t\t\tName: \"%s\",\n", f.Name)
			fmt.Printf("\t\t\tType: \"%s\",\n\n", f.Type)
			fmt.Printf("\t\t\tComment: `%s`,\n", f.Comment)
			fmt.Println("\t\t},")
		}

		fmt.Printf("\t},\n")
	}

	fmt.Println(`}`)

	return nil
}

type field struct {
	Name    string
	Type    string
	Comment string
}

func parseTypesFile(src string) (map[string][]field, error) {
	tfb, err := os.ReadFile(src)
	if err != nil {
		return nil, err
	}

	// could use the ast lib, but this is simpler

	type st int
	const (
		stGlobal st = iota // looking for typedef
		stType   st = iota // in typedef
	)

	lines := strings.Split(string(tfb), "\n")
	state := stGlobal

	var currentType string
	var currentComment []string

	out := map[string][]field{}

	for l := range lines {
		line := strings.TrimSpace(lines[l])

		switch state {
		case stGlobal:
			if strings.HasPrefix(line, "type ") {
				currentType = line
				currentType = strings.TrimPrefix(currentType, "type")
				currentType = strings.TrimSuffix(currentType, "{")
				currentType = strings.TrimSpace(currentType)
				currentType = strings.TrimSuffix(currentType, "struct")
				currentType = strings.TrimSpace(currentType)
				currentComment = nil
				state = stType
				continue
			}
		case stType:
			if strings.HasPrefix(line, "// ") {
				cline := strings.TrimSpace(strings.TrimPrefix(line, "//"))
				currentComment = append(currentComment, cline)
				continue
			}

			comment := currentComment
			currentComment = nil

			if strings.HasPrefix(line, "}") {
				state = stGlobal
				continue
			}

			f := strings.Fields(line)
			if len(f) < 2 { // empty or embedded struct
				continue
			}

			name := f[0]
			typ := f[1]

			out[currentType] = append(out[currentType], field{
				Name:    name,
				Type:    typ,
				Comment: strings.Join(comment, "\n"),
			})
		}
	}
	return out, nil
}

func main() {
	if err := run(); err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
}
